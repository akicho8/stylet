#+OPTIONS: toc:nil num:nil author:nil creator:nil \n:nil |:t
#+OPTIONS: @:t ::t ^:t -:t f:t *:t <:t

* 物理シミュレーション覚書

  - [[https://travis-ci.org/akicho8/stylet][Travis]]: [[https://travis-ci.org/akicho8/stylet.png]]
  - [[https://gemnasium.com/akicho8/stylet/][Gemnasium]]: [[https://gemnasium.com/akicho8/stylet.png]]
  - [[https://codeclimate.com/github/akicho8/stylet][Code Climate]]: [[https://codeclimate.com/github/akicho8/stylet.png]]

#  [[https://raw.github.com/akicho8/stylet/master/images/demo1.png]]
#  [[https://raw.github.com/akicho8/stylet/master/images/demo2.png]]
#  [[https://raw.github.com/akicho8/stylet/master/images/demo3.png]]
#  [[https://raw.github.com/akicho8/stylet/master/images/demo4.png]]

** セットアップ手順

   rubysdl_setup.sh より抜粋

   : brew install sdl
   : brew install sdl_mixer
   : brew install sdl_ttf
   : brew install sdl_image
   : brew install https://gist.github.com/mitmul/5410467/raw/c4fa716635e951b61f489726976b10f00dd41306/sge.rb
   : gem install rubysdl rsdl

   以下が true なら次へ

   : ruby -r sdl -e 'p [:sge, SDL.respond_to?(:autoLock)]'
   : ruby -r sdl -e 'p [:mixer, SDL.constants.include?(:Mixer)]'
   : ruby -r sdl -e 'p [:ttf, SDL.constants.include?(:TTF)]'

   rubysdl の表示確認

   : rsdl -r sdl -e 'SDL.init(SDL::INIT_EVERYTHING); SDL.set_video_mode(640, 480, 16, SDL::SWSURFACE); sleep(1)'

   このライブラリの動作確認([q]で終了)

   : rsdl -r stylet -e 'Stylet.run { vputs "Hello, world." }'

   参考

   - Mac OS X Lionにsgeを入れる http://qiita.com/items/f52daed19fa0198121b5 (2013-08-03 の時点ではSGEがTTF関連でこけてしまった)
   - MacにRuby/SDL、rsdl、SGEを入れて、ゲームライブラリMyGameを動かす http://qiita.com/noanoa07/items/88fefe232dc605720e09 (2013-08-03 の時点ではインストールできた)

# * TIPS
# 
# ** 速度ベクトルの向き取得
# 
#    : speed.angle
# 
# ** 速度ベクトルを45度傾ける
# 
#    : speed + Vector.angle_at(Fee.r45) * speed.magnitude
#    : 
#    : Vector.angle_at(speed.angle + Fee.r45) * speed.magnitude
#    : 
#    : speed.rotate(Fee.r45)
#    : 
#    : speed.rotate2(Fee.r45)
# 
# ** p0の速度ベクトルをマウスの方向に設定
# 
#    : speed = Vector.angle_at(p0.angle_to(win.mouse.point)) * speed.magnitude
# 
# ** 円の速度制限
# 
#    円が線から飛び出さないようにするときに使う
# 
#    : if speed.magnitude > radius
#    :   speed = speed.normalize.scale(radius)
#    : end
# 
# ** 線分ABの中央の位置を取得
# 
#    : half_ab = pA + Vector.angle_at(pA.angle_to(pB)) * (pA.distance_to(pB) / 2)
# 
#    : Vector.pos_vector_rate(pA, pB, 0.5)
# 
# ** 円(c,r)が点(dot)にめりこんだとき、点(dot)から円を押し出す
# 
#    悪い例
# 
#    : if c.distance_to(dot) < r
#    :   c = dot + Vector.angle_at(dot.angle_to(c)) * r
#    : end
# 
#    良い例
# 
#    : diff = c - dot
#    : rdiff = diff.magnitude - r
#    : if rdiff > 0
#    :   # c = dot + diff.normalize * r # ドットから押す場合(ドットが釘ならこれでもよい)
#    :   c += diff.normalize * rdiff
#    : end
# 
# ** 円Aと円Bをお互い離す
# 
#    跳ね返り処理は別
# 
#    : diff = b - a
#    : rdiff = r * 2 - diff.magnitude
#    : if rdiff > 0
#    :   a -= diff.normalize * rdiff / 2
#    :   b += diff.normalize * rdiff / 2
#    : end
# 
# ** 固定点Aに円(p0,r)がめり込んでいたらAから跳ね返す
# 
#    : diff = p0 - pA
#    : if diff.magnitude > 0
#    :   if diff.magnitude < r
#    :     p0 = pA + diff.normalize.scale(r)          # めりこみ解消
#    :     speed = diff.normalize.scale(speed.magnitude) # 跳ね返す
#    :   end
#    : end
# 
# ** 円Aと円Bが衝突してBからAを押したり引いたりする
# 
#    Bは動かない。また両方跳ね返らない。Aは除けるだけ
# 
#    : r2 = ar + br
#    : if a != b
#    :   diff = b - a
#    :   rdiff = r2 - diff.magnitude
#    :   # 押す場合
#    :   if rdiff > 0
#    :     # a = b + diff.normalize * r2  # Bを基点に押し出す(1)
#    :     b += diff.normalize * rdiff    # Aを基点に押し出す(2)
#    :   end
#    :   # 引く場合
#    :   if rdiff < 0
#    :     # (1) or (2) どちらでも
#    :   end
#    : end
# 
# ** 正規化とは斜めの辺の長さを 1.0 にすること
# 
#    : v.normalize.magnitude # => 1.0
# 
# ** A B C D ボタンとカーソルで操作できるとき物体(pA)と速度(speed)をコントロールするときの定石
# 
#    : # AとBで速度ベクトルの反映
#    : @pA += @speed.scale(@win.button.btA.repeat_0or1) + @speed.scale(-@win.button.btB.repeat_0or1)
#    : # @pA += @speed.scale(@win.button.btA.repeat) + @speed.scale(-@win.button.btB.repeat) # 加速したいとき
#    : 
#    : # Cボタンおしっぱなし + マウスで自機位置移動
#    : if @win.button.btC.press?
#    :   @pA = @win.cursor.clone
#    : end
#    : 
#    : # Dボタンおしっぱなし + マウスで自機角度変更
#    : if @win.button.btD.press?
#    :   if @win.cursor != @pA
#    :     # @speed = Vector.angle_at(@pA.angle_to(@win.cursor)) * @speed.radius # ← よくある間違い
#    :     @speed = (@win.cursor - @pA).normalize * @speed.magnitude # @speed.magnitude の時点で桁溢れで削れるのが嫌なら magnitude.round とする手もあり
#    :   end
#    : end
# 
# ** 円が完全に重なっている場合、ランダムに引き離す
# 
#    : diff = a - b
#    : if diff.magnitude.zero?
#    :   arrow = Vector.nonzero_random_new
#    :   a -= arrow * ar
#    :   b += arrow * br
#    : end
# 
# ** 同時押しシミュレート
# 
#    : # A:←A S:←B D:→A F:→B
#    : @axis.left  << (SDL::Key.press?(SDL::Key::A) | SDL::Key.press?(SDL::Key::S))
#    : @axis.right << (SDL::Key.press?(SDL::Key::D) | SDL::Key.press?(SDL::Key::F))
#    : @button.btA << (SDL::Key.press?(SDL::Key::A) | SDL::Key.press?(SDL::Key::D))
#    : @button.btB << (SDL::Key.press?(SDL::Key::S) | SDL::Key.press?(SDL::Key::F))
# 
# ** 内積の取得
# 
#    : v = Vector.dot_product(a, b)
# 
#    1. ←← or →→ 正 (0.0 < v)   お互いだいたい同じ方向を向いている
#    2. →←         負 (v   < 0.0) お互いだいたい逆の方向を向いている
#    3. →↓ →↑    零 (0.0)       お互いが直角の関係
# 
# * 参照
# 
#   - Flashゲーム講座&アクションスクリプトサンプル集 http://hakuhin.jp/as.html
#   - 基礎の基礎編その１ 内積と外積の使い方 http://marupeke296.com/COL_Basic_No1_InnerAndOuterProduct.html
#   - 内積が角度になる証明 http://marupeke296.com/COL_Basic_No1_DotProof.html
#   - 衝突判定編 http://marupeke296.com/COL_main.html
#   - 反射ベクトルと壁ずりベクトル http://marupeke296.com/COL_Basic_No5_WallVector.html
